%header {:

package de.unikl.bcverifier.isl.parser;
import de.unikl.bcverifier.isl.ast.*;


:};


%embed {:
	private ArrayList<ParserError> errors = new ArrayList<ParserError>();

	public ArrayList<ParserError> getErrors() {
		return errors;
	}
	
	{ 
		// Use error handler in parser
		report = new Events(); 
	} 
	
	class Events extends Parser.Events {
		public void syntaxError(Symbol token) {
			SyntaxError e = new SyntaxError("Syntactic error: unexpected token " + Terminals.NAMES[token.getId()], Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()), token);
            errors.add(e);
		}

		public void scannerError(Scanner.Exception e) {
			LexicalError err = new LexicalError("Lexical error: " + e.getMessage(), e.line, e.column);
			errors.add(err);
		}
		public void unexpectedTokenRemoved(Symbol token) {
			// do nothing
		}

		public void missingTokenInserted(Symbol token) {
			// do nothing
		}

		public void misspelledTokenReplaced(Symbol token) {
			// do nothing
		}

		public void errorPhraseRemoved(Symbol error) {
			// do nothing
		}
	}
	
	/** convert array to ast-list */
	private <T extends ASTNode<?>> List<T> list(T[] ar) {
		List<T> result = new List<T>();
		for (T t : ar) {
			result.add(t);
		}
		return result;
	}
	
	
:};


%terminals FORALL, TRUE, FALSE, INVALIDTOKEN, OLD, NEW, IDENTIFIER, INVARIANT, LOCAL,
	PROGRAMPOINT, IN,
	PLACE, LINE, WHERE, 
	// TERMINATION_MEASURE,
	IF, THEN, ELSE,
	DOT,
	MOD, MULT, DIV, PLUS, MINUS, LT, LTEQ, GT, GTEQ, NOT,
	EQUALS, UNEQUALS,
	COLON, COLONCOLON, COMMA, LPAREN, RPAREN, SEMI, EQ,
	IMPLIES, IFF, AND, OR, RELATED,
	INTLITERAL, NULL
;

// operator precedences, highest first
%right NOT;
%left DOT; 
%left MOD, MULT, DIV;
%left PLUS, MINUS;
%left RELATED;
%left EQUALS, UNEQUALS, LT, LTEQ, GT, GTEQ;
%left AND;
%left OR;
%right IMPLIES;
%left IFF;
%left THEN;
%left FORALL;

%typeof id = "Ident";
%typeof vardefs = "List<VarDef>";
%typeof vardef = "VarDef";
%typeof expr = "Expr";
%typeof idlist = "List<Ident>";
%typeof typedef = "TypeDef";
%typeof cu = "CompilationUnit";
%typeof parameterlist = "List<Expr>";
%typeof nonEmptyParameterlist = "List<Expr>";
%typeof statement = "Statement";
%typeof placeposition = "ProgramPointExpr";

%goal cu;

cu = 
	  statement.s* 
		{: return new CompilationUnit(list(s)); :} 
	| INVALIDTOKEN.t
    	{: return null; :}
;

statement = 
	  INVARIANT expr.e SEMI
		{: return new Invariant(e); :}
	| LOCAL INVARIANT expr.e SEMI
		{: return new LocalInvariant(e); :}
	| PROGRAMPOINT id.i EQ placeposition.pos SEMI
		{: return new ProgramPoint(i, pos); :}
	| PLACE id.i EQ expr.pos WHERE expr.cond SEMI
		{: return new PlaceDef(i, pos, new Opt<Expr>(cond) , new Opt<Expr>()); :}
;



expr =
      FORALL vardefs.v COLONCOLON expr.e
      	{: return new ForallExpr(v,e); :}
    | TRUE  
    	{: return new BoolConst(true); :}
    | FALSE 
    	{: return new BoolConst(false); :}
    | INTLITERAL.i
    	{: return new IntConst(i); :}
    | NULL
    	{: return new NullConst(); :}
    | id.i
    	{: return new VarAccess(i); :}
    | id.f LPAREN parameterlist.p RPAREN
    	{: return new FuncCall(f, p); :} 
    | expr.left DOT id.right
    	{: return new MemberAccess(left, right); :}
    | expr.left RELATED expr.right
    	{: return new BinaryOperation(BinaryOperator.RELATED, left, right); :}
    | expr.left IMPLIES expr.right
    	{: return new BinaryOperation(BinaryOperator.IMPLIES, left, right); :}
    | expr.left IFF expr.right
    	{: return new BinaryOperation(BinaryOperator.IFF, left, right); :}
    | expr.left AND expr.right
    	{: return new BinaryOperation(BinaryOperator.AND, left, right); :}
    | expr.left OR expr.right
    	{: return new BinaryOperation(BinaryOperator.OR, left, right); :}
    | expr.left PLUS expr.right
    	{: return new BinaryOperation(BinaryOperator.PLUS, left, right); :}
    | expr.left MINUS expr.right
    	{: return new BinaryOperation(BinaryOperator.MINUS, left, right); :}
    | expr.left MULT expr.right
    	{: return new BinaryOperation(BinaryOperator.MULT, left, right); :}
    | expr.left DIV expr.right
    	{: return new BinaryOperation(BinaryOperator.DIV, left, right); :}
    | expr.left MOD expr.right
    	{: return new BinaryOperation(BinaryOperator.MOD, left, right); :}
    | expr.left EQUALS expr.right
    	{: return new BinaryOperation(BinaryOperator.EQUALS, left, right); :}
    | expr.left UNEQUALS expr.right
    	{: return new BinaryOperation(BinaryOperator.UNEQUALS, left, right); :}
    | expr.left LT expr.right
    	{: return new BinaryOperation(BinaryOperator.LT, left, right); :}
    | expr.left LTEQ expr.right
    	{: return new BinaryOperation(BinaryOperator.LTEQ, left, right); :}
    | expr.left GT expr.right
    	{: return new BinaryOperation(BinaryOperator.GT, left, right); :}
    | expr.left GTEQ expr.right
    	{: return new BinaryOperation(BinaryOperator.GTEQ, left, right); :}
    | NOT expr.e
    	{: return new UnaryOperation(UnaryOperator.NOT, e); :}
    | MINUS expr.e
    	{: return new UnaryOperation(UnaryOperator.UMINUS, e); :}
    | IF expr.cond THEN expr.e1 ELSE expr.e2
    	{: return new IfThenElse(cond, e1, e2); :}
    | LPAREN expr.e RPAREN
    | placeposition.e
;

placeposition = 
	  LINE INTLITERAL.lineNr IN typedef.t 
	  	{: return new LineNrProgramPoint(t, Integer.parseInt((String)lineNr.value)); :}
;


parameterlist =
	  nonEmptyParameterlist
	| 
		{: return new List<Expr>(); :}
;

nonEmptyParameterlist = 
	  expr.e 
	  	{: return new List().add(e); :}
	| nonEmptyParameterlist.es COMMA expr.e
		{: return es.add(e); :}
;


 vardefs =
 	  vardef.v 
 	  	{: return new List().add(v); :}
 	| vardefs.vs COMMA vardef.v 
 		{: return vs.add(v); :}
 ;
 
 vardef = 
 	  typedef.t id.n 
 	  	{: return new VarDef(t, n); :}
;

typedef = 
	  OLD idlist.n
		{: return new NamedTypeDef(Version.OLD, n); :}
	| NEW idlist.n
		{: return new NamedTypeDef(Version.NEW, n); :}
	| idlist.n
		{: return new NamedTypeDef(Version.BOTH, n); :}
;

idlist =
	  id.i 
 	  	{: return new List().add(i); :}
 	| idlist.is DOT id.i 
 		{: return is.add(i); :}
;

id = 
	IDENTIFIER.i
		{: return new Ident(i); :}
;

 	   