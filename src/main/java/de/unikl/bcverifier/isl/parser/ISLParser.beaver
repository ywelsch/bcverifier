%header {:

package de.unikl.bcverifier.isl.parser;
import de.unikl.bcverifier.isl.ast.*;


:};


%embed {:
	private ArrayList<ParserError> errors = new ArrayList<ParserError>();

	public ArrayList<ParserError> getErrors() {
		return errors;
	}
	
	{ 
		// Use error handler in parser
		report = new Events(); 
	} 
	
	class Events extends Parser.Events {
		public void syntaxError(Symbol token) {
			SyntaxError e = new SyntaxError("Syntactic error: unexpected token " + Terminals.NAMES[token.getId()], Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()), token);
            errors.add(e);
		}

		public void scannerError(Scanner.Exception e) {
			LexicalError err = new LexicalError("Lexical error: " + e.getMessage(), e.line, e.column);
			errors.add(err);
		}
		public void unexpectedTokenRemoved(Symbol token) {
			// do nothing
		}

		public void missingTokenInserted(Symbol token) {
			// do nothing
		}

		public void misspelledTokenReplaced(Symbol token) {
			// do nothing
		}

		public void errorPhraseRemoved(Symbol error) {
			// do nothing
		}
	}
	
	/** convert array to ast-list */
	private <T extends ASTNode<?>> List<T> list(T[] ar) {
		List<T> result = new List<T>();
		for (T t : ar) {
			result.add(t);
		}
		return result;
	}
	
	
:};


%terminals FORALL, TRUE, FALSE, INVALIDTOKEN, OLD, NEW, IDENTIFIER,
	IF, THEN, ELSE,
	DOT,
	MOD, MULT, DIV, PLUS, MINUS, NOT,
	EQUALS, UNEQUALS,
	LBRACKET, RBRACKET, COMMA, LPAREN, RPAREN,
	IMPLIES, AND, OR, RELATED,
	INTLITERAL, NULL
;

// operator precedences, highest first
%right NOT;
%left DOT; 
%left MOD, MULT, DIV;
%left PLUS, MINUS;
%left RELATED;
%left EQUALS, UNEQUALS;
%left AND;
%left OR;
%right IMPLIES;
%left THEN;

%typeof id = "Ident";
%typeof vardefs = "List<VarDef>";
%typeof vardef = "VarDef";
%typeof expr = "Expr";
%typeof idlist = "List<Ident>";
%typeof typedef = "TypeDef";
%typeof cu = "CompilationUnit";
%typeof parameterlist = "List<Expr>";
%typeof nonEmptyParameterlist = "List<Expr>";

%goal cu;

cu = 
	  expr.e* 
		{: return new CompilationUnit(list(e)); :} 
	| INVALIDTOKEN.t
    	{: return null; :}
;

expr =
      FORALL vardefs.v LBRACKET expr.e RBRACKET 
      	{: return new ForallExpr(v,e); :}
    | TRUE  
    	{: return new BoolConst(true); :}
    | FALSE 
    	{: return new BoolConst(false); :}
    | INTLITERAL.i
    	{: return new IntConst(i); :}
    | NULL
    	{: return new NullConst(); :}
    | id.i
    	{: return new VarAccess(i); :}
    | id.f LPAREN parameterlist.p RPAREN
    	{: return new FuncCall(f, p); :} 
    | expr.left DOT id.right
    	{: return new MemberAccess(left, right); :}
    | expr.left RELATED expr.right
    	{: return new BinaryOperation(BinaryOperator.RELATED, left, right); :}
    | expr.left IMPLIES expr.right
    	{: return new BinaryOperation(BinaryOperator.IMPLIES, left, right); :}
    | expr.left AND expr.right
    	{: return new BinaryOperation(BinaryOperator.AND, left, right); :}
    | expr.left OR expr.right
    	{: return new BinaryOperation(BinaryOperator.OR, left, right); :}
    | expr.left PLUS expr.right
    	{: return new BinaryOperation(BinaryOperator.PLUS, left, right); :}
    | expr.left MINUS expr.right
    	{: return new BinaryOperation(BinaryOperator.MINUS, left, right); :}
    | expr.left MULT expr.right
    	{: return new BinaryOperation(BinaryOperator.MULT, left, right); :}
    | expr.left DIV expr.right
    	{: return new BinaryOperation(BinaryOperator.DIV, left, right); :}
    | expr.left MOD expr.right
    	{: return new BinaryOperation(BinaryOperator.MOD, left, right); :}
    | expr.left EQUALS expr.right
    	{: return new BinaryOperation(BinaryOperator.EQUALS, left, right); :}
    | expr.left UNEQUALS expr.right
    	{: return new BinaryOperation(BinaryOperator.UNEQUALS, left, right); :}
    | NOT expr.e
    	{: return new UnaryOperation(UnaryOperator.NOT, e); :}
    | MINUS expr.e
    	{: return new UnaryOperation(UnaryOperator.UMINUS, e); :}
    | IF expr.cond THEN expr.e1 ELSE expr.e2
    	{: return new IfThenElse(cond, e1, e2); :}
    | LPAREN expr.e RPAREN
;

parameterlist =
	  nonEmptyParameterlist
	| 
		{: return new List<Expr>(); :}
;

nonEmptyParameterlist = 
	  expr.e 
	  	{: return new List().add(e); :}
	| nonEmptyParameterlist.es COMMA expr.e
		{: return es.add(e); :}
;


 vardefs =
 	  vardef.v 
 	  	{: return new List().add(v); :}
 	| vardefs.vs COMMA vardef.v 
 		{: return vs.add(v); :}
 ;
 
 vardef = 
 	  typedef.t id.n 
 	  	{: return new VarDef(t, n); :}
;

typedef = 
	  OLD idlist.n
		{: return new NamedTypeDef(Version.OLD, n); :}
	| NEW idlist.n
		{: return new NamedTypeDef(Version.NEW, n); :}
	| idlist.n
		{: return new NamedTypeDef(Version.BOTH, n); :}
;

idlist =
	  id.i 
 	  	{: return new List().add(i); :}
 	| idlist.is DOT id.i 
 		{: return is.add(i); :}
;

id = 
	IDENTIFIER.i
		{: return new Ident(i); :}
;

 	   